"""
Servicio de limpieza automática de archivos exportados y datos antiguos
"""
import os
import glob
import threading
import time
from typing import Optional
from config.settings import DATA_DIR
from utils.logger import get_logger

logger = get_logger(__name__)


class CleanupService:
    """
    Servicio background que limpia periódicamente archivos exportados
    y datos antiguos de la base de datos.

    Características:
    - Singleton: Solo una instancia en toda la aplicación
    - Thread-safe: Seguro para concurrencia
    - Daemon: Se cierra automáticamente con el programa
    - Configurable: límites de archivos y antigüedad ajustables
    """

    _instance: Optional['CleanupService'] = None
    _lock = threading.Lock()

    # ── Configuración por defecto ─────────────────────────────────────────────
    DEFAULT_MAX_CSV        = 10      # Máx. archivos CSV a conservar
    DEFAULT_MAX_PNG        = 10      # Máx. archivos PNG a conservar
    DEFAULT_DB_DAYS        = 30      # Días de datos a conservar en BD
    DEFAULT_INTERVAL_HOURS = 24      # Cada cuántas horas limpiar

    def __new__(cls, *args, **kwargs):
        """Singleton: solo una instancia"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(
        self,
        data_logger=None,
        max_csv: int = DEFAULT_MAX_CSV,
        max_png: int = DEFAULT_MAX_PNG,
        db_days: int = DEFAULT_DB_DAYS,
        interval_hours: float = DEFAULT_INTERVAL_HOURS,
    ):
        """
        Inicializa el servicio (solo la primera vez).

        Args:
            data_logger:     Instancia de DataLogger para limpiar la BD.
                             Si es None, solo se limpian archivos.
            max_csv:         Número máximo de CSV exportados a conservar.
            max_png:         Número máximo de PNG exportados a conservar.
            db_days:         Días de histórico a conservar en la BD.
            interval_hours:  Horas entre ejecuciones del ciclo de limpieza.
        """
        if hasattr(self, '_initialized'):
            return

        self.data_logger    = data_logger
        self.max_csv        = max_csv
        self.max_png        = max_png
        self.db_days        = db_days
        self.interval_hours = interval_hours

        self._running = False
        self._thread: Optional[threading.Thread] = None
        self._initialized = True

        logger.info(
            f"[CleanupService] Configurado — "
            f"CSV: {max_csv}, PNG: {max_png}, "
            f"BD: {db_days}d, intervalo: {interval_hours}h"
        )

    # ── Ciclo de vida ─────────────────────────────────────────────────────────

    def start(self):
        """Inicia el servicio en segundo plano."""
        if self._running:
            logger.info("[CleanupService] Ya está corriendo")
            return

        self._running = True
        self._thread = threading.Thread(
            target=self._run,
            daemon=True,
            name="CleanupService"
        )
        self._thread.start()
        logger.info("[CleanupService] Servicio iniciado")

    def stop(self):
        """Detiene el servicio."""
        if not self._running:
            return
        self._running = False
        if self._thread:
            self._thread.join(timeout=5)
        logger.info("[CleanupService] Servicio detenido")

    def _run(self):
        """Bucle principal: limpia al arrancar y luego cada interval_hours."""
        # Primera limpieza inmediata al arrancar
        self._cleanup_cycle()

        interval_seconds = self.interval_hours * 3600
        elapsed = 0.0
        while self._running:
            time.sleep(0.5)
            elapsed += 0.5
            if elapsed >= interval_seconds:
                self._cleanup_cycle()
                elapsed = 0.0

    # ── Lógica de limpieza ────────────────────────────────────────────────────

    def _cleanup_cycle(self):
        """Ejecuta un ciclo completo de limpieza."""
        logger.info("[CleanupService] Iniciando ciclo de limpieza")
        self.clean_csv()
        self.clean_png()
        if self.data_logger:
            self.clean_db()
        logger.info("[CleanupService] Ciclo de limpieza completado")

    def clean_csv(self, max_files: int = None) -> int:
        """
        Elimina los CSV exportados más antiguos que superen el límite.

        Args:
            max_files: Límite a aplicar. Si es None usa self.max_csv.

        Returns:
            Número de archivos eliminados.
        """
        limit = max_files if max_files is not None else self.max_csv
        pattern = os.path.join(str(DATA_DIR), "history_*.csv")
        return self._trim_files(pattern, limit, "CSV")

    def clean_png(self, max_files: int = None) -> int:
        """
        Elimina los PNG exportados más antiguos que superen el límite.

        Args:
            max_files: Límite a aplicar. Si es None usa self.max_png.

        Returns:
            Número de archivos eliminados.
        """
        limit = max_files if max_files is not None else self.max_png
        pattern = os.path.join(str(DATA_DIR), "screenshots", "*.png")
        return self._trim_files(pattern, limit, "PNG")

    def clean_db(self, days: int = None) -> bool:
        """
        Elimina registros de la BD más antiguos que 'days' días.

        Args:
            days: Antigüedad máxima. Si es None usa self.db_days.

        Returns:
            True si la limpieza fue exitosa.
        """
        if not self.data_logger:
            logger.warning("[CleanupService] No hay data_logger configurado")
            return False

        d = days if days is not None else self.db_days
        try:
            self.data_logger.clean_old_data(days=d)
            logger.info(f"[CleanupService] BD limpiada — registros >'{d}' días eliminados")
            return True
        except Exception as e:
            logger.error(f"[CleanupService] Error limpiando BD: {e}")
            return False

    def _trim_files(self, pattern: str, max_files: int, label: str) -> int:
        """
        Elimina los archivos más antiguos que superen max_files.

        Args:
            pattern:   Patrón glob de los archivos a gestionar.
            max_files: Número máximo a conservar.
            label:     Etiqueta para el log.

        Returns:
            Número de archivos eliminados.
        """
        try:
            files = sorted(glob.glob(pattern), key=os.path.getmtime)
            to_delete = files[:-max_files] if len(files) > max_files else []
            for f in to_delete:
                try:
                    os.remove(f)
                    logger.info(f"[CleanupService] {label} eliminado: {os.path.basename(f)}")
                except Exception as e:
                    logger.warning(f"[CleanupService] No se pudo eliminar {f}: {e}")
            if to_delete:
                logger.info(
                    f"[CleanupService] {label}: {len(to_delete)} eliminados, "
                    f"{len(files) - len(to_delete)} conservados"
                )
            return len(to_delete)
        except Exception as e:
            logger.error(f"[CleanupService] Error en _trim_files ({label}): {e}")
            return 0

    # ── Información y estado ──────────────────────────────────────────────────

    def get_status(self) -> dict:
        """
        Devuelve el estado actual del servicio.

        Returns:
            Diccionario con configuración y estado del hilo.
        """
        csv_files = glob.glob(os.path.join(str(DATA_DIR), "history_*.csv"))
        png_files = glob.glob(os.path.join(str(DATA_DIR), "screenshots", "*.png"))
        return {
            'running':        self._running,
            'thread_alive':   self._thread.is_alive() if self._thread else False,
            'interval_hours': self.interval_hours,
            'max_csv':        self.max_csv,
            'max_png':        self.max_png,
            'db_days':        self.db_days,
            'csv_count':      len(csv_files),
            'png_count':      len(png_files),
        }

    def force_cleanup(self) -> dict:
        """
        Fuerza un ciclo de limpieza inmediato desde fuera del hilo.
        Útil para llamadas manuales desde la UI.

        Returns:
            Diccionario con el número de archivos eliminados y resultado de BD.
        """
        logger.info("[CleanupService] Limpieza forzada manualmente")
        deleted_csv = self.clean_csv()
        deleted_png = self.clean_png()
        db_ok = self.clean_db() if self.data_logger else False
        logger.info(
            f"[CleanupService] Limpieza manual completada — "
            f"CSV: {deleted_csv}, PNG: {deleted_png}, BD: {db_ok}"
        )
        return {'deleted_csv': deleted_csv, 'deleted_png': deleted_png, 'db_ok': db_ok}

    def is_running(self) -> bool:
        """Verifica si el servicio está corriendo."""
        return self._running
